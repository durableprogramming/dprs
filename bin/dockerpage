#!/usr/bin/env ruby

require 'bundler/inline'

gemfile do
  source 'https://rubygems.org'
  gem 'docker-api'
  gem 'terminal-table'
  gem 'curses'
  gem 'tty-screen'
  gem 'tty-table'
  gem 'pastel'
  gem 'clipboard'
  gem 'launchy'
end

require 'docker-api'
require 'csv'
require 'terminal-table'
require 'curses'
require 'tty-screen'
require 'tty-table'
require 'pastel'
require 'clipboard'
require 'launchy'

port_data = {}

class DockerTUI
  def initialize
    @selected_index = 0
  end

  def col_fmt(raw, width)
    out = raw.dup

    if out.length > width
      overage = out.length - ( width )
      out = out[0..(-(overage+7))] + '...' + out[-3..-1]
    end

    puts 'oopsy' if out.length > width
    out = out.ljust(width)
    out
  end
  def run
    Curses.init_screen
    Curses.start_color
    Curses.cbreak
    Curses.noecho
    Curses.stdscr.keypad(true)
    Curses.curs_set 0
    Curses.timeout = 1

        
    Curses.init_pair(1, 0, 0)
    Curses.init_pair(2, 16, 2)
    Curses.init_pair(3, 2, 0)
    Curses.init_pair(4, 3, 0)
    Curses.init_pair(5, 4, 0)
    Curses.init_pair(6, 5, 0)
    Curses.init_pair(7, 6, 0)
    Curses.init_pair(8, 7, 0)
    Curses.init_pair(9, 8, 0)
    Curses.init_pair(10, 9, 0)
    begin
      update_screen

      die = false
      while !die
        key = Curses.getch
        case key
        when 'q'
          die = true
        when 'k'
          @selected_index -= 1
        when 'j'
          @selected_index += 1
        when 'c'
          Clipboard.copy(@display_rows[@selected_index][2])
        when 'l'
          Launchy.open( "http://" + @display_rows[@selected_index][2])
        when 'x'
          @display_row_containers[@selected_index].stop
        end

        update_screen
      end
    ensure
      Curses.close_screen
    end
  end

  private

  def update_screen
    @containers = Docker::Container.all
    headers = ['Container Name', 'Image', 'Private IPs', 'Ports']
    pastel = Pastel.new
    table = TTY::Table.new(headers, [])


    @display_rows = []
    @display_row_containers = []
    idx = 0 
    @selected_index = [0,@selected_index].max
    @selected_index = [@containers.length-1,@selected_index].min
    @containers.each do |container|

      @display_row_containers[idx] = container


      row = [container.info['Names'][0].gsub(/^\//, '')]
      row << container.info['Image']

      ips = []

      container.info.dig('NetworkSettings', 'Networks').each do |name, net|
        ips << net['IPAddress']
      end

      row << ips.first #.join(', ').slice(0..32)

      ports = []
      (container.info['Ports']).each do |portspec|
        ports << [portspec['PublicPort'], portspec['PrivatePort']].join(":")
      end

      row << ports.sort.join(', ').slice(0..32)
      
      @display_rows[idx] = row
      idx += 1
    end

    idx = 0
    @display_rows.each do |row|
      Curses.setpos( (idx)*1, 0)
      if idx == @selected_index

        Curses.attron(Curses.color_pair(2)) do
          out = []
          row.each_with_index  { |v,k| out.push col_fmt(v, k == 0 ? 30 : 16)  }
         
          Curses.addstr( out .join(" | ") + "\n\n") 
        end
          
      else
        Curses.attron(Curses.color_pair(3)) do
          out = []
          row.each_with_index  { |v,k| out.push col_fmt(v, k == 0 ? 30 : 16)  }
         
          Curses.addstr( out .join(" | ") + "\n\n") 
        end
      end

      idx +=1
    end

    Curses.refresh
    #Curses.addstr(table.render(:unicode, resize: true))
  end
end

DockerTUI.new.run
