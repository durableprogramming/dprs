0a1,2
> use std::io;
> use std::process::Command;
2c4
<     event::{self, Event, KeyCode, KeyEvent, KeyModifiers},
---
>     event::{self, DisableMouseCapture, EnableMouseCapture, Event, KeyCode},
6d7
< use std::{io, time::Duration};
8c9
<     backend::CrosstermBackend,
---
>     backend::{Backend, CrosstermBackend},
11,12c12,14
<     widgets::{Block, Borders, List, ListItem, Paragraph},
<     Terminal,
---
>     text::{Span, Spans},
>     widgets::{Block, Borders, List, ListItem, ListState},
>     Frame, Terminal,
14d15
< use clipboard::{ClipboardContext, ClipboardProvider};
16,20c17,23
< mod app;
< use app::{
<     actions::{copy_ip_address, open_browser, stop_container},
<     state_machine::{AppEvent, AppState},
< };
---
> struct Container {
>     name: String,
>     image: String,
>     ip_address: String,
>     ports: String,
>     status: String,
> }
22,28c25,28
< fn main() -> Result<(), Box<dyn std::error::Error>> {
<     // Set up terminal
<     enable_raw_mode()?;
<     let mut stdout = io::stdout();
<     execute!(stdout, EnterAlternateScreen)?;
<     let backend = CrosstermBackend::new(stdout);
<     let mut terminal = Terminal::new(backend)?;
---
> struct App {
>     containers: Vec<Container>,
>     state: ListState,
> }
30,32c30,36
<     // Create app state
<     let mut app_state = AppState::new();
<     app_state.load_containers();
---
> impl App {
>     fn new() -> App {
>         App {
>             containers: Vec::new(),
>             state: ListState::default(),
>         }
>     }
34,35c38,77
<     // Start the main loop
<     let res = run_app(&mut terminal, &mut app_state);
---
>     fn load_containers(&mut self) {
>         self.containers.clear();
>         
>         let output = Command::new("docker")
>             .args(["ps", "--format", "{{.Names}}|{{.Image}}|{{.Ports}}|{{.Status}}"])
>             .output()
>             .expect("Failed to execute docker ps");
>         
>         let output_str = String::from_utf8_lossy(&output.stdout);
>         
>         for line in output_str.lines() {
>             let parts: Vec<&str> = line.split('|').collect();
>             if parts.len() >= 4 {
>                 let name = parts[0].to_string();
>                 let image = parts[1].to_string();
>                 let ports = parts[2].to_string();
>                 let status = parts[3].to_string();
>                 
>                 // Get container IP address
>                 let ip_output = Command::new("docker")
>                     .args(["inspect", "--format", "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}", &name])
>                     .output()
>                     .expect("Failed to get container IP");
>                 
>                 let ip_address = String::from_utf8_lossy(&ip_output.stdout).trim().to_string();
>                 
>                 self.containers.push(Container {
>                     name,
>                     image,
>                     ip_address,
>                     ports,
>                     status,
>                 });
>             }
>         }
>         
>         if !self.containers.is_empty() && self.state.selected().is_none() {
>             self.state.select(Some(0));
>         }
>     }
37,40c79,91
<     // Restore terminal
<     disable_raw_mode()?;
<     execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
<     terminal.show_cursor()?;
---
>     fn next(&mut self) {
>         let i = match self.state.selected() {
>             Some(i) => {
>                 if i >= self.containers.len() - 1 {
>                     0
>                 } else {
>                     i + 1
>                 }
>             }
>             None => 0,
>         };
>         self.state.select(Some(i));
>     }
42,43c93,104
<     if let Err(err) = res {
<         println!("Error: {}", err);
---
>     fn previous(&mut self) {
>         let i = match self.state.selected() {
>             Some(i) => {
>                 if i == 0 {
>                     self.containers.len() - 1
>                 } else {
>                     i - 1
>                 }
>             }
>             None => 0,
>         };
>         self.state.select(Some(i));
46c107,146
<     Ok(())
---
>     fn open_browser(&self) {
>         if let Some(selected) = self.state.selected() {
>             if let Some(container) = self.containers.get(selected) {
>                 let url = format!("http://{}", container.ip_address);
>                 
>                 #[cfg(target_os = "linux")]
>                 Command::new("xdg-open").arg(&url).spawn().ok();
>                 
>                 #[cfg(target_os = "macos")]
>                 Command::new("open").arg(&url).spawn().ok();
>                 
>                 #[cfg(target_os = "windows")]
>                 Command::new("cmd").args(["/c", "start", &url]).spawn().ok();
>             }
>         }
>     }
> 
>     fn copy_ip(&self) {
>         if let Some(selected) = self.state.selected() {
>             if let Some(container) = self.containers.get(selected) {
>                 // This is a simplified version - in a real implementation,
>                 // you would use a clipboard library
>                 println!("IP copied: {}", container.ip_address);
>             }
>         }
>     }
> 
>     fn stop_container(&mut self) {
>         if let Some(selected) = self.state.selected() {
>             if let Some(container) = self.containers.get(selected) {
>                 Command::new("docker")
>                     .args(["stop", &container.name])
>                     .output()
>                     .expect("Failed to stop container");
>                 
>                 // Reload containers to reflect the changes
>                 self.load_containers();
>             }
>         }
>     }
49,52c149,161
< fn run_app<B: tui::backend::Backend>(
<     terminal: &mut Terminal<B>,
<     app_state: &mut AppState,
< ) -> Result<(), Box<dyn std::error::Error>> {
---
> fn main() -> Result<(), io::Error> {
>     // Setup terminal
>     enable_raw_mode()?;
>     let mut stdout = io::stdout();
>     execute!(stdout, EnterAlternateScreen, EnableMouseCapture)?;
>     let backend = CrosstermBackend::new(stdout);
>     let mut terminal = Terminal::new(backend)?;
> 
>     // Create app and load containers
>     let mut app = App::new();
>     app.load_containers();
> 
>     // Main loop
54,157c163
<         terminal.draw(|f| {
<             let chunks = Layout::default()
<                 .direction(Direction::Vertical)
<                 .margin(2)
<                 .constraints([
<                     Constraint::Length(1),
<                     Constraint::Min(0),
<                     Constraint::Length(3),
<                 ])
<                 .split(f.size());
< 
<             let title = Paragraph::new("DPRS - Docker Container Manager")
<                 .style(Style::default().fg(Color::Cyan));
<             f.render_widget(title, chunks[0]);
< 
<             let items: Vec<ListItem> = app_state
<                 .containers
<                 .iter()
<                 .map(|container| {
<                     ListItem::new(format!(
<                         "{} | {} | {} | {}",
<                         container.name, container.image, container.ip_address, container.ports
<                     ))
<                 })
<                 .collect();
< 
<             let containers = List::new(items)
<                 .block(Block::default().borders(Borders::ALL).title("Containers"))
<                 .highlight_style(
<                     Style::default()
<                         .bg(Color::LightBlue)
<                         .add_modifier(Modifier::BOLD),
<                 )
<                 .highlight_symbol("> ");
< 
<             f.render_stateful_widget(containers, chunks[1], &mut app_state.list_state);
< 
<             let help = Paragraph::new(
<                 "q: Quit | j/↓: Down | k/↑: Up | c: Copy IP | l: Open in Browser | x: Stop Container | r: Reload",
<             )
<             .block(Block::default().borders(Borders::ALL).title("Help"));
<             f.render_widget(help, chunks[2]);
<         })?;
< 
<         // Handle input
<         if event::poll(Duration::from_millis(100))? {
<             if let Event::Key(key) = event::read()? {
<                 let event = match key {
<                     KeyEvent {
<                         code: KeyCode::Char('q'),
<                         ..
<                     } => AppEvent::Quit,
<                     KeyEvent {
<                         code: KeyCode::Char('j'),
<                         ..
<                     }
<                     | KeyEvent {
<                         code: KeyCode::Down,
<                         ..
<                     } => AppEvent::Next,
<                     KeyEvent {
<                         code: KeyCode::Char('k'),
<                         ..
<                     }
<                     | KeyEvent {
<                         code: KeyCode::Up,
<                         ..
<                     } => AppEvent::Previous,
<                     KeyEvent {
<                         code: KeyCode::Char('c'),
<                         ..
<                     } => {
<                         match copy_ip_address(app_state) {
<                             Ok(_) => {},
<                             Err(e) => eprintln!("Error copying IP: {}", e),
<                         }
<                         AppEvent::CopyIP
<                     },
<                     KeyEvent {
<                         code: KeyCode::Char('l'),
<                         ..
<                     } => {
<                         match open_browser(app_state) {
<                             Ok(_) => {},
<                             Err(e) => eprintln!("Error opening browser: {}", e),
<                         }
<                         AppEvent::OpenBrowser
<                     },
<                     KeyEvent {
<                         code: KeyCode::Char('x'),
<                         ..
<                     } => {
<                         match stop_container(app_state) {
<                             Ok(_) => {},
<                             Err(e) => eprintln!("Error stopping container: {}", e),
<                         }
<                         AppEvent::StopContainer
<                     },
<                     KeyEvent {
<                         code: KeyCode::Char('r'),
<                         ..
<                     } => AppEvent::Reload,
<                     _ => continue,
<                 };
---
>         terminal.draw(|f| ui(f, &mut app))?;
159,161c165,174
<                 if !app_state.handle_event(event) {
<                     break;
<                 }
---
>         if let Event::Key(key) = event::read()? {
>             match key.code {
>                 KeyCode::Char('q') => break,
>                 KeyCode::Char('j') => app.next(),
>                 KeyCode::Char('k') => app.previous(),
>                 KeyCode::Char('c') => app.copy_ip(),
>                 KeyCode::Char('l') => app.open_browser(),
>                 KeyCode::Char('x') => app.stop_container(),
>                 KeyCode::Char('r') => app.load_containers(),
>                 _ => {}
165a179,187
>     // Restore terminal
>     disable_raw_mode()?;
>     execute!(
>         terminal.backend_mut(),
>         LeaveAlternateScreen,
>         DisableMouseCapture
>     )?;
>     terminal.show_cursor()?;
> 
166a189,230
> }
> 
> fn ui<B: Backend>(f: &mut Frame<B>, app: &mut App) {
>     let chunks = Layout::default()
>         .direction(Direction::Vertical)
>         .margin(1)
>         .constraints([Constraint::Percentage(100)].as_ref())
>         .split(f.size());
> 
>     let items: Vec<ListItem> = app.containers
>         .iter()
>         .map(|container| {
>             let lines = vec![
>                 Spans::from(vec![
>                     Span::styled(
>                         format!("{} ", container.name),
>                         Style::default().fg(Color::Green).add_modifier(Modifier::BOLD),
>                     ),
>                     Span::raw(format!("({})", container.image)),
>                 ]),
>                 Spans::from(vec![
>                     Span::styled("IP: ", Style::default().fg(Color::Blue)),
>                     Span::raw(&container.ip_address),
>                     Span::styled(" Ports: ", Style::default().fg(Color::Blue)),
>                     Span::raw(&container.ports),
>                 ]),
>                 Spans::from(vec![
>                     Span::styled("Status: ", Style::default().fg(Color::Yellow)),
>                     Span::raw(&container.status),
>                 ]),
>                 Spans::from(""),
>             ];
>             ListItem::new(lines)
>         })
>         .collect();
> 
>     let list = List::new(items)
>         .block(Block::default().title("Docker Containers").borders(Borders::ALL))
>         .highlight_style(Style::default().bg(Color::DarkGray))
>         .highlight_symbol("> ");
> 
>     f.render_stateful_widget(list, chunks[0], &mut app.state);
