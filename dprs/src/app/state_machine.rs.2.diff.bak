0a1,157
> use std::process::Command;
> use tui::widgets::ListState;
> 
> pub struct Container {
>     pub name: String,
>     pub image: String,
>     pub ip_address: String,
>     pub ports: String,
>     pub status: String,
> }
> 
> pub struct AppState {
>     pub containers: Vec<Container>,
>     pub list_state: ListState,
> }
> 
> pub enum AppEvent {
>     Next,
>     Previous,
>     CopyIP,
>     OpenBrowser,
>     StopContainer,
>     Reload,
>     Quit,
> }
> 
> impl AppState {
>     pub fn new() -> Self {
>         Self {
>             containers: Vec::new(),
>             list_state: ListState::default(),
>         }
>     }
> 
>     pub fn load_containers(&mut self) {
>         self.containers.clear();
>         
>         let output = Command::new("docker")
>             .args(["ps", "--format", "{{.Names}}|{{.Image}}|{{.Ports}}|{{.Status}}"])
>             .output()
>             .expect("Failed to execute docker ps");
>         
>         let output_str = String::from_utf8_lossy(&output.stdout);
>         
>         for line in output_str.lines() {
>             let parts: Vec<&str> = line.split('|').collect();
>             if parts.len() >= 4 {
>                 let name = parts[0].to_string();
>                 let image = parts[1].to_string();
>                 let ports = parts[2].to_string();
>                 let status = parts[3].to_string();
>                 
>                 // Get container IP address
>                 let ip_output = Command::new("docker")
>                     .args(["inspect", "--format", "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}", &name])
>                     .output()
>                     .expect("Failed to get container IP");
>                 
>                 let ip_address = String::from_utf8_lossy(&ip_output.stdout).trim().to_string();
>                 
>                 self.containers.push(Container {
>                     name,
>                     image,
>                     ip_address,
>                     ports,
>                     status,
>                 });
>             }
>         }
>         
>         if !self.containers.is_empty() && self.list_state.selected().is_none() {
>             self.list_state.select(Some(0));
>         }
>     }
> 
>     pub fn handle_event(&mut self, event: AppEvent) -> bool {
>         match event {
>             AppEvent::Next => self.next(),
>             AppEvent::Previous => self.previous(),
>             AppEvent::CopyIP => self.copy_ip(),
>             AppEvent::OpenBrowser => self.open_browser(),
>             AppEvent::StopContainer => self.stop_container(),
>             AppEvent::Reload => self.load_containers(),
>             AppEvent::Quit => return false,
>         }
>         true
>     }
> 
>     fn next(&mut self) {
>         let i = match self.list_state.selected() {
>             Some(i) => {
>                 if i >= self.containers.len() - 1 {
>                     0
>                 } else {
>                     i + 1
>                 }
>             }
>             None => 0,
>         };
>         self.list_state.select(Some(i));
>     }
> 
>     fn previous(&mut self) {
>         let i = match self.list_state.selected() {
>             Some(i) => {
>                 if i == 0 {
>                     self.containers.len() - 1
>                 } else {
>                     i - 1
>                 }
>             }
>             None => 0,
>         };
>         self.list_state.select(Some(i));
>     }
> 
>     fn open_browser(&self) {
>         if let Some(selected) = self.list_state.selected() {
>             if let Some(container) = self.containers.get(selected) {
>                 let url = format!("http://{}", container.ip_address);
>                 
>                 #[cfg(target_os = "linux")]
>                 Command::new("xdg-open").arg(&url).spawn().ok();
>                 
>                 #[cfg(target_os = "macos")]
>                 Command::new("open").arg(&url).spawn().ok();
>                 
>                 #[cfg(target_os = "windows")]
>                 Command::new("cmd").args(["/c", "start", &url]).spawn().ok();
>             }
>         }
>     }
> 
>     fn copy_ip(&self) {
>         if let Some(selected) = self.list_state.selected() {
>             if let Some(container) = self.containers.get(selected) {
>                 // This is a simplified version - in a real implementation,
>                 // you would use a clipboard library
>                 println!("IP copied: {}", container.ip_address);
>             }
>         }
>     }
> 
>     fn stop_container(&mut self) {
>         if let Some(selected) = self.list_state.selected() {
>             if let Some(container) = self.containers.get(selected) {
>                 Command::new("docker")
>                     .args(["stop", &container.name])
>                     .output()
>                     .expect("Failed to stop container");
>                 
>                 // Reload containers to reflect the changes
>                 self.load_containers();
>             }
>         }
>     }
> }
